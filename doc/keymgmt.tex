\section{How to Share a File}

In our hybrid cryptosystem, the challenge for sharing files rests in
managing keys correctly and efficiently. We consider three designs in
our discussion.

Recall that our hybrid cryptosystem takes advantage of the ability of
block ciphers (i.e., AES-256) to cipher efficiently any file with a
password while public key cryptography (i.e., RSA) enables us to
control access to the file password.

\subsection{User Experience}

Since our system is motivated by the convenience affordance of systems
like Dropbox, we want to make it easy for everyday users to bootstrap
their usage of \name. In this subsection, we outline how we make it
possible for users to have a simplified user experience.

\subsubsection*{New \name User}

We have two classes of users at whom \name is directed.

\paragraph{Receive Invitation} The more challenging of the two
scenarios is where a non-\name user receives an invitation to view a
file through \name.

The user receives a URL as in Figure~\ref{fig:inviteurl} in a fun but
professional email inviting the user to accept their friend's
invitation to download \name and receive a file using the \name
service.

\begin{figure*} {\tt
    http://sdb.trustycloudapps.com/invite.py?to=<email
    addr>\&from=<email addr>}
\caption{What the URL looks like.}
\label{fig:inviteurl}
\end{figure*}

\begin{figure*}
{\tt http://sdb.trustycloudapps.com/sendpub.py?bucket=<bucketname>}
\caption{For each bucket in the \name system, we store the public keys
  in a predefined object name in the bucket. This object contains a
  JSON-formatted dictionary of (location, public key) pairs for the
  bucket owner's email address. This makes it easy to locate the keys
  and share the identity with the friend.}
\label{fig:inviteurl}
\end{figure*}


Once the user chooses to download the \name application, she is
presented with a ``Downloading \name...'' screen, which demonstrates
the simple installation steps. That screen also contains a prominent
announcement of the link to click once the \name application has been
installed.

This link contains a link that leverages a MIME type registered during
the installation of \name. This MIME type enables the current and all
future shared file links to be accessible. \note{Register MIME type on
  Mac. Register right-click menu option for files/directories
  (contextual menu items).}

Once the user has installed the application, she clicks a link that
automatically sends her public key to the friend who sent her the
original invitation. The original user now can add the friend's (new
\name user) public key to the \name address book.

\paragraph{Self-motivated} In the case that a user decides to install
\name out of their own volition, setup is straightforward.

\paragraph{Increasing Privacy} To reduce the trusted code base in the
cloud, the users can opt to share invitations and public keys through
emailing encrypted ``bundles'' that only \name can open.


\subsubsection*{Existing \name User}

Sharing a link with a user involves simply clicking on a link that the
\name program parses. \name is able to determine from the link and the
contents of the S3 bucket whether a version of the file exists for the
current user. If it does (meaning that the private key of the current
\name instance can decrypt the file) then the user can download the
file can fetch the file. 

If a version does not exist, then the user must share their public key
with the other user.

\subsection{How to Share a Key}

Sharing a key has been a question asked and addressed by researchers
since Shamir~\cite{shamir}.

Our system assumes that users can trust the cloud. In fact, the users
can trust the cloud with their files and, in particular, with key
exchanges.

\subsection{Everytime, A New Password}

When a user updates a file we can generate a new block cipher
password, encrypt this password with all of the file friends' public
keys, and upload the generated files to the cloud.

\subsection{Hash Chains}

\note{maybe...}

\subsection{Mix with Deltas and Stir}

We encrypt the deltas. But happens when we revoke access or grant new
access to a file? Or, worse, revoke access then regrant a few versions
later?